#!/usr/bin/env python3
"""
MinerU内容总结器 - 统一入口
集成所有最佳特性的统一版本
"""

import asyncio
import sys
from pathlib import Path
import argparse

# 添加项目根目录到Python路径
sys.path.insert(0, str(Path(__file__).parent))

from src.config.unified_config import load_unified_config, save_config_template
from src.core.summary_engine import SummaryEngine
from src.core.backend_manager import BackendManager
from src.core.document_parser import DocumentParser
from src.core.image_uploader import ImageUploader


def create_parser() -> argparse.ArgumentParser:
    """创建命令行参数解析器"""
    parser = argparse.ArgumentParser(
        description="MinerU内容总结器 - 统一版本",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
示例用法:
  # 生成配置模板
  mineru-summarizer --init-config

  # 基础总结
  mineru-summarizer input_dir output.md

  # 指定压缩级别和配置
  mineru-summarizer input_dir output.md --compression 30 --config config.yaml

  # 启用二次打磨
  mineru-summarizer input_dir output.md --polish

  # 启用Debug模式保存所有pairs
  mineru-summarizer input_dir output.md --debug-pairs

  # 恢复中断的任务
  mineru-summarizer --resume session_id

  # 管理检查点
  mineru-summarizer --list-checkpoints
  mineru-summarizer --clean-checkpoints 7
  
  # Debug模式 - 查看文档分片
  mineru-summarizer input_dir --debug-chunks

  # 图片上传功能
  mineru-summarizer upload-images input.md output.md --config config.yaml

特性:
  ✅ 基于Markdown header的大章节分片 (V3特性)
  ✅ 支持LLM API和Claude CLI后端切换
  ✅ 检查点恢复机制，防止限流中断
  ✅ 可选的二次打磨功能
  ✅ 智能过滤无关章节 (References等)
  ✅ 专有技术名词保护
  ✅ Debug模式：预览文档分片效果
  ✅ Debug模式：保存所有(原文,总结)对用于追溯
  ✅ 图片上传：自动上传本地图片到S3并替换链接
        """
    )
    
    # 子命令支持
    subparsers = parser.add_subparsers(dest="command", help="可用命令")
    
    # upload-images子命令
    upload_parser = subparsers.add_parser(
        "upload-images", 
        help="上传Markdown文件中的本地图片到S3",
        description="检测Markdown文件中的本地图片引用，上传到S3并替换为公网链接"
    )
    upload_parser.add_argument("input_file", type=Path, help="输入的Markdown文件")
    upload_parser.add_argument("output_file", type=Path, help="输出的Markdown文件")
    upload_parser.add_argument("--dry-run", action="store_true", help="只检测图片，不实际上传")
    upload_parser.add_argument("--backup", action="store_true", help="创建原文件备份")
    
    # 默认的主要操作参数（为了兼容性，避免与子命令参数冲突）
    parser.add_argument("input_dir", nargs="?", type=Path, help="输入目录 (包含full.md)")
    parser.add_argument("summary_output", nargs="?", type=Path, help="总结输出文件路径")
    
    # 总结配置
    parser.add_argument("--compression", "-c", type=int, default=50, choices=[30, 50, 70, 100],
                       help="压缩级别 (30=精简, 50=标准, 70=详细, 100=翻译)")
    parser.add_argument("--polish", action="store_true", help="启用二次打磨")
    parser.add_argument("--debug-pairs", action="store_true", help="Debug模式：保存所有(原文,总结)对，用于追溯翻译过程")
    
    # 全局配置和后端参数
    parser.add_argument("--config", type=Path, help="配置文件路径")
    parser.add_argument("--backend", choices=["llm_api", "claude_cli"], help="强制使用指定后端")
    
    # 检查点管理
    parser.add_argument("--resume", type=str, help="恢复指定会话ID")
    parser.add_argument("--list-checkpoints", action="store_true", help="列出所有检查点")
    parser.add_argument("--clean-checkpoints", type=int, metavar="DAYS", help="清理N天前的检查点")
    
    # 工具功能
    parser.add_argument("--init-config", action="store_true", help="生成配置文件模板")
    parser.add_argument("--validate", action="store_true", help="验证配置和后端")
    parser.add_argument("--debug-chunks", action="store_true", help="Debug模式：只分片文档，输出分片内容，不进行总结")
    
    return parser


def print_banner():
    """打印横幅"""
    print("=" * 70)
    print("🚀 MinerU内容总结器 - 统一版本")
    print("=" * 70)
    print("✨ 特性: 大章节分片 + 多后端 + 检查点恢复 + 二次打磨")
    print("")


async def debug_chunks(input_dir: Path, config):
    """Debug模式：只分片文档并输出每个分片内容"""
    print("🔍 Debug模式：文档分片调试")
    print(f"📂 输入目录: {input_dir}")
    
    # 解析文档
    print("\n📚 解析Markdown文档...")
    full_md_path = input_dir / "full.md"
    parser = DocumentParser(config.processing.max_tokens_per_chapter)
    chapter_chunks = parser.parse_markdown_file(full_md_path)
    
    print(f"✅ 解析完成，生成 {len(chapter_chunks)} 个分片")
    parser.print_statistics(chapter_chunks)
    
    # 输出每个分片的详细内容
    print("\n" + "=" * 70)
    print("📄 分片内容详情")
    print("=" * 70)
    
    for i, chunk in enumerate(chapter_chunks, 1):
        print(f"\n🔖 分片 {i}: {chunk.id}")
        print(f"📝 标题: {chunk.chapter_title}")
        print(f"📊 层级: {chunk.chapter_level}")
        print(f"🔢 Token数: {chunk.token_count:,}")
        print(f"📋 子章节数: {len(chunk.sub_sections)}")
        
        if chunk.sub_sections:
            print("📚 子章节:")
            for sub in chunk.sub_sections[:10]:  # 最多显示10个子章节
                print(f"   • {sub}")
            if len(chunk.sub_sections) > 10:
                print(f"   ... 还有 {len(chunk.sub_sections) - 10} 个子章节")
        
        print(f"\n📖 内容预览 (前500字符):")
        print("-" * 50)
        preview_content = chunk.content[:500]
        print(preview_content)
        if len(chunk.content) > 500:
            print("...")
            print(f"(完整内容共 {len(chunk.content)} 字符)")
        print("-" * 50)
        
        # 问用户是否要看完整内容
        if len(chunk.content) > 500:
            user_input = input(f"\n💡 是否查看完整内容? (y/N): ").strip().lower()
            if user_input in ['y', 'yes']:
                print("\n📄 完整内容:")
                print("=" * 50)
                print(chunk.content)
                print("=" * 50)
        
        # 在每个分片之间暂停，让用户可以仔细查看
        if i < len(chapter_chunks):
            user_input = input(f"\n⏸️ 按 Enter 继续查看下一个分片，或输入 'q' 退出: ").strip().lower()
            if user_input == 'q':
                break
    
    print(f"\n🎉 Debug完成！总共检查了 {len(chapter_chunks)} 个分片")
    print("💡 提示：如果分片看起来正确，你可以运行正常的总结命令")


async def handle_upload_images(args):
    """处理图片上传命令"""
    print("🖼️ 图片上传模式")
    print(f"📂 输入文件: {args.input_file}")
    print(f"📄 输出文件: {args.output_file}")
    
    # 验证输入文件
    if not args.input_file.exists():
        print(f"❌ 错误: 输入文件不存在: {args.input_file}")
        sys.exit(1)
    
    if not args.input_file.suffix.lower() in ['.md', '.markdown']:
        print(f"❌ 错误: 输入文件必须是Markdown格式: {args.input_file}")
        sys.exit(1)
    
    # 加载配置
    try:
        config = load_unified_config(args.config)
        
        if not config.s3.enabled:
            print("❌ 错误: S3配置未启用，请在配置文件中设置 s3.enabled: true")
            print("💡 提示: 使用 --init-config 生成配置模板")
            sys.exit(1)
        
    except Exception as e:
        print(f"❌ 配置加载失败: {e}")
        print("💡 提示: 使用 --init-config 生成配置模板")
        sys.exit(1)
    
    # 创建备份
    if args.backup:
        backup_path = args.input_file.with_suffix(f"{args.input_file.suffix}.backup")
        print(f"💾 创建备份: {backup_path}")
        import shutil
        shutil.copy2(args.input_file, backup_path)
    
    try:
        # 初始化图片上传器
        uploader = ImageUploader(config, dry_run=args.dry_run)
        
        if args.dry_run:
            print("🔍 Dry Run 模式：只检测图片，不上传")
            
            # 读取文件
            with open(args.input_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # 查找图片
            base_dir = args.input_file.parent
            found_images = uploader.find_local_images(content, base_dir)
            
            if not found_images:
                print("📄 未找到本地图片引用")
                return
            
            print(f"📸 找到 {len(found_images)} 个图片引用:")
            for i, img_info in enumerate(found_images, 1):
                status = "✅ 存在" if img_info["is_valid"] else "❌ 不存在"
                print(f"  {i}. {img_info['image_path']} -> {img_info['local_path']} ({status})")
            
            valid_count = sum(1 for img in found_images if img["is_valid"])
            print(f"\n📊 统计: 总计 {len(found_images)} 个，有效 {valid_count} 个")
            
        else:
            # 实际处理
            processed_content, stats = uploader.process_markdown_file(args.input_file)
            
            # 写入输出文件
            with open(args.output_file, 'w', encoding='utf-8') as f:
                f.write(processed_content)
            
            print(f"\n🎉 处理完成!")
            print(f"📄 输出文件: {args.output_file}")
            print(f"📊 统计: 总计 {stats['total']} 个图片")
            print(f"  ✅ 成功上传: {stats['uploaded']} 个")
            print(f"  ⏭️ 跳过: {stats['skipped']} 个")
            print(f"  ❌ 错误: {stats['errors']} 个")
            
            if stats['errors'] > 0:
                print("⚠️ 存在错误的图片引用，请检查日志")
        
    except ImportError:
        print("❌ 缺少依赖: 请安装 boto3")
        print("💡 运行: pip install boto3")
        sys.exit(1)
    except Exception as e:
        print(f"❌ 处理失败: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


async def main():
    """主函数"""
    parser = create_parser()
    args = parser.parse_args()
    
    print_banner()
    
    # 处理图片上传命令
    if args.command == "upload-images":
        await handle_upload_images(args)
        return
    
    # 处理工具功能
    if args.init_config:
        config_path = Path("mineru-config.yaml")
        save_config_template(config_path)
        print(f"✅ 配置模板已生成: {config_path}")
        print("请编辑配置文件后使用 --config 参数指定")
        return
    
    # 加载配置
    try:
        config = load_unified_config(args.config)
        
        # 如果指定了后端，覆盖配置
        if args.backend:
            print(f"🔧 强制使用后端: {args.backend}")
            if args.backend == "llm_api":
                from src.config.unified_config import LLMAPIConfig
                config.backend = LLMAPIConfig()
            elif args.backend == "claude_cli":
                from src.config.unified_config import ClaudeCLIConfig
                config.backend = ClaudeCLIConfig()
        
        # 如果指定了polish，覆盖配置
        if args.polish:
            config.polish.enabled = True
            print("✨ 启用二次打磨")
        
        # 如果指定了debug-pairs，设置标志
        debug_pairs_enabled = args.debug_pairs
        if debug_pairs_enabled:
            print("🔍 启用Debug模式：将保存所有(原文,总结)对")
        
    except Exception as e:
        print(f"❌ 配置加载失败: {e}")
        print("💡 提示: 使用 --init-config 生成配置模板")
        sys.exit(1)
    
    # 验证配置
    if args.validate:
        print("🔍 验证配置...")
        if BackendManager.validate_backend(config):
            print("✅ 配置验证通过")
        else:
            print("❌ 配置验证失败")
            sys.exit(1)
        return
    
    # 处理Debug模式
    if args.debug_chunks:
        if not args.input_dir:
            print("❌ 错误: Debug模式需要提供输入目录")
            print("💡 使用: mineru-summarizer input_dir --debug-chunks")
            sys.exit(1)
        
        # 验证输入
        if not args.input_dir.exists():
            print(f"❌ 错误: 输入目录不存在: {args.input_dir}")
            sys.exit(1)
        
        full_md_path = args.input_dir / "full.md"
        if not full_md_path.exists():
            print(f"❌ 错误: 未找到full.md文件: {full_md_path}")
            sys.exit(1)
        
        await debug_chunks(args.input_dir, config)
        return
    
    # 创建总结引擎
    engine = SummaryEngine(config)
    
    # 处理检查点管理
    if args.list_checkpoints:
        engine.list_checkpoints()
        return
    
    if args.clean_checkpoints is not None:
        engine.clean_checkpoints(args.clean_checkpoints)
        return
    
    # 处理恢复任务
    if args.resume:
        print(f"🔄 恢复会话: {args.resume}")
        try:
            await engine.summarize(
                input_dir=Path("."),  # 占位符
                output_path=Path("."),  # 占位符
                resume_session=args.resume
            )
        except Exception as e:
            print(f"❌ 恢复失败: {e}")
            sys.exit(1)
        return
    
    # 处理新任务
    if not args.input_dir or not args.summary_output:
        print("❌ 错误: 需要提供输入目录和输出文件")
        print("💡 使用 --help 查看详细用法")
        sys.exit(1)
    
    # 验证输入
    if not args.input_dir.exists():
        print(f"❌ 错误: 输入目录不存在: {args.input_dir}")
        sys.exit(1)
    
    full_md_path = args.input_dir / "full.md"
    if not full_md_path.exists():
        print(f"❌ 错误: 未找到full.md文件: {full_md_path}")
        sys.exit(1)
    
    # 验证后端
    if not BackendManager.validate_backend(config):
        print("❌ 后端验证失败")
        sys.exit(1)
    
    # 执行总结任务
    try:
        await engine.summarize(
            input_dir=args.input_dir,
            output_path=args.summary_output,
            compression_level=args.compression,
            debug_pairs=debug_pairs_enabled
        )
        
        print(f"\n🎉 任务完成!")
        print(f"📄 输出文件: {args.summary_output}")
        
        if config.processing.enable_checkpoint:
            print(f"💡 提示: 如果任务被中断，使用 --list-checkpoints 查看可恢复的会话")
        
    except KeyboardInterrupt:
        print(f"\n⏸️ 任务被中断")
        if config.processing.enable_checkpoint:
            print("💾 进度已保存，使用 --list-checkpoints 查看检查点")
        sys.exit(1)
    except Exception as e:
        print(f"❌ 执行失败: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


def sync_main():
    """同步入口点"""
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n👋 再见!")
        sys.exit(0)


if __name__ == "__main__":
    sync_main()